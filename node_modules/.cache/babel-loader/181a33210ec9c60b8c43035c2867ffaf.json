{"ast":null,"code":"// newRoll falls back to a 1d20 roll if no other parameters are provided.\n// It returns an object of the total and the results. The form newRoll().total\n// is a common usage.\nconst newRoll = (dieCount = 1, dieType = 20, bonus = 0) => {\n  let results = [];\n\n  for (var i = 0; i < dieCount; i++) {\n    results.push({\n      type: dieType,\n      value: Math.ceil(Math.random() * dieType)\n    });\n  }\n\n  let total = bonus;\n  results.forEach(result => {\n    total += result.value;\n  });\n  return {\n    total,\n    results\n  };\n}; // Both roll and rolls create and then modify an object, which\n// they return when the function is done.\n\n\nexports.roll = (dieCount = 1, dieType = 20, bonus = 0) => {\n  const rollObj = {\n    dieCount: dieCount,\n    dieType: dieType,\n    bonus: bonus,\n    lastRoll: 0,\n    results: Array.from({\n      length: dieCount\n    }, (v, k) => {\n      return {\n        type: dieType,\n        value: 0\n      };\n    })\n  };\n\n  rollObj.get = () => {\n    const ourRoll = newRoll(rollObj.dieCount, rollObj.dieType, rollObj.bonus);\n    rollObj.lastRoll = ourRoll.total;\n    rollObj.results = ourRoll.results;\n    return rollObj.lastRoll;\n  };\n\n  return rollObj;\n}; // rolls can be used in conjunction with rolls, or by passing\n// in a collection of objects like what roll returns, however we can\n// also pass in our own array of dice.\n\n\nexports.rolls = (rolls, bonus = 0) => {\n  const dice = {\n    rolls: rolls,\n    lastRoll: 0,\n    results: [],\n    bonus: bonus\n  };\n  dice.rolls.forEach(roll => {\n    roll.dieCount = roll.dieCount || 1;\n    roll.dieType = roll.dieType || 6;\n    if (roll.bonus) dice.bonus += roll.bonus;\n    delete roll.bonus;\n  }); // get becomes a permanent method on the object\n\n  dice.get = () => {\n    dice.lastRoll = dice.bonus;\n    dice.results = [];\n    dice.rolls.forEach(rollObj => {\n      const makeRoll = newRoll(rollObj.dieCount, rollObj.dieType, 0);\n      dice.lastRoll += makeRoll.total;\n      dice.results = dice.results.concat(makeRoll.results);\n    });\n    return dice.lastRoll;\n  };\n\n  return dice;\n};\n\nexports.newRoll = newRoll;","map":{"version":3,"sources":["/Users/daniele/Documents/GitHub/paroliere/node_modules/react-dice/diceLogic.js"],"names":["newRoll","dieCount","dieType","bonus","results","i","push","type","value","Math","ceil","random","total","forEach","result","exports","roll","rollObj","lastRoll","Array","from","length","v","k","get","ourRoll","rolls","dice","makeRoll","concat"],"mappings":"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","sourcesContent":["// newRoll falls back to a 1d20 roll if no other parameters are provided.\n// It returns an object of the total and the results. The form newRoll().total\n// is a common usage.\nconst newRoll = (dieCount = 1, dieType = 20, bonus = 0) => {\n\tlet results = [];\n\tfor (var i = 0; i < dieCount; i++) {\n\t\tresults.push({ type: dieType, value: Math.ceil(Math.random() * dieType) });\n\t}\n\tlet total = bonus;\n\tresults.forEach(result => {\n\t\ttotal += result.value;\n\t});\n\treturn { total, results };\n};\n\n// Both roll and rolls create and then modify an object, which\n// they return when the function is done.\nexports.roll = (dieCount = 1, dieType = 20, bonus = 0) => {\n\tconst rollObj = {\n\t\tdieCount: dieCount,\n\t\tdieType: dieType,\n\t\tbonus: bonus,\n\t\tlastRoll: 0,\n\t\tresults: Array.from({ length: dieCount }, (v, k) => {\n\t\t\treturn { type: dieType, value: 0 };\n\t\t}),\n\t};\n\trollObj.get = () => {\n\t\tconst ourRoll = newRoll(rollObj.dieCount, rollObj.dieType, rollObj.bonus);\n\t\trollObj.lastRoll = ourRoll.total;\n\t\trollObj.results = ourRoll.results;\n\t\treturn rollObj.lastRoll;\n\t};\n\treturn rollObj;\n};\n\n// rolls can be used in conjunction with rolls, or by passing\n// in a collection of objects like what roll returns, however we can\n// also pass in our own array of dice.\nexports.rolls = (rolls, bonus = 0) => {\n\tconst dice = {\n\t\trolls: rolls,\n\t\tlastRoll: 0,\n\t\tresults: [],\n\t\tbonus: bonus,\n\t};\n\tdice.rolls.forEach(roll => {\n\t\troll.dieCount = roll.dieCount || 1;\n\t\troll.dieType = roll.dieType || 6;\n\t\tif (roll.bonus) dice.bonus += roll.bonus;\n\t\tdelete roll.bonus;\n\t});\n\t// get becomes a permanent method on the object\n\tdice.get = () => {\n\t\tdice.lastRoll = dice.bonus;\n\t\tdice.results = [];\n\t\tdice.rolls.forEach(rollObj => {\n\t\t\tconst makeRoll = newRoll(rollObj.dieCount, rollObj.dieType, 0);\n\t\t\tdice.lastRoll += makeRoll.total;\n\t\t\tdice.results = dice.results.concat(makeRoll.results);\n\t\t});\n\t\treturn dice.lastRoll;\n\t};\n\treturn dice;\n};\n\nexports.newRoll = newRoll;\n"]},"metadata":{},"sourceType":"script"}